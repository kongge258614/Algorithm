行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、
                      访问者模式、中介者模式、解释器模式。

一、观察者模式：
    定义对象间的一种一对多的依赖关系。当一个对象的状态发生改变时，所有依赖它的对象都会得到通知并进行自定义处理。

    步骤：1.目标对象的定义
          2.具体目标对象的定义
          3.观察者的接口定义
          4.观察者的具体实现

    从六大方面重新认识观察者模式：
        1.目标与观察者之间的关系：可以是一个目标对应多个观察者，也可以是多个目标对应一个观察者
        2.单向依赖：只能是观察者依赖目标，不能是目标依赖观察者
        3.命名建议：观察者模式被称为发布订阅模式。
                    ① 目标接口的定义，建议在名称后面跟Subject
                    ② 观察者接口的定义，建议在名称后面跟Observer
                    ③ 观察者接口的更新方法，建议命名为update
        4.触发通知时机
        5.观察者模式的调用顺序示意图
        6.通知的顺序

    观察者模式实现的两种模型：推模型和拉模型
        推模型：目标对象主动向观察者推送目标的详细信息，推送的信息为目标对象的全部信息或部分信息。

        拉模型; 目标对象在通知观察者的时候，只传递少量的信息。如果观察者需要更多的信息，那么观察者主动到目标对象中去获取。相当于观察者对象
                去目标对象中拉取数据。

                实现这种模型时，一般是把目标对象自身通过update方法传递给观察者对象。
    观察者模式的虽然细分为两种模型，本质上就是一种模型：推模型。在实际项目中，信息会包含type(信息类型)字段，各个观察者会根据type字段判断，该消息是不是自身需要
    的消息，如果是则继续处理，如果不是，则直接return。

    利用Java提供的观察者实现   Java.util.Observerable

    Java实现与自己实现的对比;
        1.不需要在自定义观察者和目标的接口了，jdk帮忙实现了。
        2.具体的目标对象里面不需要再维护观察者的注册信息了，这个再Java的Observer类里面已经实现好了。
        3.触发通知的方式有一些改变，要先调用setChanged方法，这个是Java为了帮助实现更精确的触发控制而提供的功能。
        4.具体的观察者的实现里面，update其实能同时支持推模型和拉模型，这个Java在定义的时候已经考虑好了。
    观察者模式的使用场景：
        1.一个抽象模型有两个方面，其中一个方面依赖于另一个方面的状态变化。
        2.如果更改一个对象的状态的时候，需要同时连带更改多个对象的状态，且不知道究竟有多少对象跟着改变。
        3.当一个对象必须通知其他对象，且该对象与其他对象松散耦合。




