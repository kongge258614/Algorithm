行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、
                      访问者模式、中介者模式、解释器模式。

一、观察者模式：
    定义对象间的一种一对多的依赖关系。当一个对象的状态发生改变时，所有依赖它的对象都会得到通知并进行自定义处理。

    步骤：1.目标对象的定义
          2.具体目标对象的定义
          3.观察者的接口定义
          4.观察者的具体实现

    从六大方面重新认识观察者模式：
        1.目标与观察者之间的关系：可以是一个目标对应多个观察者，也可以是多个目标对应一个观察者
        2.单向依赖：只能是观察者依赖目标，不能是目标依赖观察者
        3.命名建议：观察者模式被称为发布订阅模式。
                    ① 目标接口的定义，建议在名称后面跟Subject
                    ② 观察者接口的定义，建议在名称后面跟Observer
                    ③ 观察者接口的更新方法，建议命名为update
        4.触发通知时机
        5.观察者模式的调用顺序示意图
        6.通知的顺序

    观察者模式实现的两种模型：推模型和拉模型
        推模型：目标对象主动向观察者推送目标的详细信息，推送的信息为目标对象的全部信息或部分信息。

        拉模型; 目标对象在通知观察者的时候，只传递少量的信息。如果观察者需要更多的信息，那么观察者主动到目标对象中去获取。相当于观察者对象
                去目标对象中拉取数据。

                实现这种模型时，一般是把目标对象自身通过update方法传递给观察者对象。
    观察者模式的虽然细分为两种模型，本质上就是一种模型：推模型。在实际项目中，信息会包含type(信息类型)字段，各个观察者会根据type字段判断，该消息是不是自身需要
    的消息，如果是则继续处理，如果不是，则直接return。

    利用Java提供的观察者实现   Java.util.Observerable

    Java实现与自己实现的对比;
        1.不需要在自定义观察者和目标的接口了，jdk帮忙实现了。
        2.具体的目标对象里面不需要再维护观察者的注册信息了，这个再Java的Observer类里面已经实现好了。
        3.触发通知的方式有一些改变，要先调用setChanged方法，这个是Java为了帮助实现更精确的触发控制而提供的功能。
        4.具体的观察者的实现里面，update其实能同时支持推模型和拉模型，这个Java在定义的时候已经考虑好了。
    观察者模式的使用场景：
        1.一个抽象模型有两个方面，其中一个方面依赖于另一个方面的状态变化。
        2.如果更改一个对象的状态的时候，需要同时连带更改多个对象的状态，且不知道究竟有多少对象跟着改变。
        3.当一个对象必须通知其他对象，且该对象与其他对象松散耦合。
    具体场景; subject：type（0、1、2、3）        observerA(当type=1时，接收消息)、observerB(当type=3时，接收消息)
        思路;当subject和observer在同一个项目中时，直接循环通知，然后由observer根据type判断是否继续处理。
             当subject和observer不在同一个项目中时(例如：微服务项目），可选择的实在for循环的下发通知时，先判断是否下发。
--------------------------------------------------------------------------------------------------------------------------------------------------

二、责任链模式(Chain of handler Model)：
        责任链模式将接收者对象连成一个链条，并在该链条上传递请求，直到有一个接收者对象处理它。通过让更多对象有机会处理请求，避免了请求发送者和处理
    者之间的耦合。发出请求的客户端并不知道链上的哪一个接收者会处理这个请求，从而实现了客户端和接收者之间的解耦。

    步骤：
        1.定义一个抽象类，该类是实现责任链模式的关键，整个链路上的所有节点都继承这个抽象类。在该类中定义一个对该类本身的引用，目的是将下一个节点
          注册到该节点来，形成一个链路，这样各个节点之间便连接起来。(类比一下数据结构中的链表)
        2.定义一个责任链工厂，创建责任链。
        3.在各个节点中实现抽象方法。
        4.在客户端调用首节点的处理方法。（因为在每个节点中都有指向下一个节点的调用，所以如果当前节点无法处理，那么流程会走到下一个节点）

----------------------------------------------------------------------------------------------------------------------------------------------------------
三、策略模式(Strategy mode):
        策略模式是将可变的部分从程序中抽离出来，形成一个算法接口，在该接口下分别封装不同的算法实现。并且算法之间可以相互替换。从而实现客户端程序
    独立于算法的改变。即客户端不会感知算法的改变。

        组合：
